/*
   random_walk.cpp
   Purpose: To simulate random walks on a square lattice for the percolation problem

   @author: Yousof Mardoukhi
   @version: 1.1 12/12/2017

*/

/*
   Returns a two dimensional pointer storing the position trajectory of random walks
   @params: t total number of steps
            n the integer number of the random walk instance (for the case if an output file is required)
            size the size of the square lattice
            board the square lattice realisation of the percolation problem
            latt_num the intger number of the square lattice instance (for the case if an output file is required)
   @returs position a two dimensional pointer storing the trajectory of random walks

*/
//------------------Diffusion function--------------//
int **random_walk(int t, int n, int size, int **board, int latt_num)
{
	board[size/2][size/2]=0;

	ofstream position_file;									//Streaming of position of the particle
	char filename[30];									//Initiating a char variable filename which will contain the name of the file which the position of the particle will be stored on it

	int x_pos = size/2, y_pos = size/2;							//Defining the temporal x and y position of the particle and initiating them at the centre
	float ran_num;										//Defining a float variable for storing the random number generated by ran1 function (debugging)

	int **position = new int*[t];								//Initializing the position dynamic array of the particle
	
	for(int i=0; i<t; i++)
	{
		position[i] = new int[2];
	}
	

	x_pos = size/2;										//Setting the initial x_position of the particle at the centre
	y_pos = size/2;										//Setting the initial y_position of the particle at the centre


	position[0][0] = x_pos;									//Storing the initial x-position of the particle at time i=0
	position[0][1] = y_pos;									//Storing the initial y-position of the particle at time i=0
		
		
		
	//if (n<3)										//This if statement dictates to only store 4-first run position of the particle
	//{
	//	sprintf(filename,"%s%d%s%d","par_pos_",n,"_",latt_num);				//Naming the "filename" for different run
		//sprintf(debg_name,"%s%d%s%d","debag_",n,"_",latt_num);																	
	//	position_file.open(filename);							//Open a text file "par_pos%d.txt" for streaming the particle position
		//debug_file.open(debg_name);
		
	//	position_file << position[0][0] << "\t" << position[0][1] << endl;
	//}

	for (int i=1 ; i < t ; i++)								//A for loop going through the time steps
	{
		ran_num = ran1(&idum1);								//Storing the random number generated by function ran1 in ran_num

		if (ran_num < 0.25)								//Upward movement
		{
			if (y_pos != size-1)							//For the case that the particle is not at the boundary
			{
				if (board[x_pos][y_pos+1] == 0)					//Check if the right nearby cell is not occupied;
				{
					y_pos = y_pos+1;					//The temporal y_position of the particle is increased by one
					position[i][0] = position[i-1][0];			//The x-position of the particle is stored in i_th(time) element of position_x array
						
					position[i][1] = position[i-1][1]+1;			//The y-position of the particle is stored in i_th(time) element of position_y array
				}
				else								//If the nearby cell is occupied;
				{
					position[i][0] = position[i-1][0];			//The x-position of the particle remains the same
					position[i][1] = position[i-1][1];			//The y-position of the particle remains the same
				}
			}
			else									//For the case that the particle is at the boundary
			{
				if (board[x_pos][0] == 0)					//Check if the nearby cell on the other side of the board is not occupied
				{
					y_pos = 0;						//Update the temporal y-position of the particle
					position[i][0] = position[i-1][0];			//Storing the temporal x-position of the particle
					position[i][1] = position[i-1][1]+1;			//Storing the temporal y-position of the particle
				}
				else								//If the nearby cell on the other side of the board is occupied
				{
					position[i][0] = position[i-1][0];			//Storing the current temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Storing the current temporal y-position of the particle
				}
			}
		}
		if (ran_num >= 0.25 && ran_num < 0.5)						//Downward movement
		{
			if (y_pos != 0)								//For the case that the particle is not at the boundary
			{
				if (board[x_pos][y_pos-1] == 0)					//Check that if the nearby cell is not occupied
				{
					y_pos = y_pos-1;					//Update the temporal y-position of the particle
					position[i][0] = position[i-1][0];			//Storing the temporal x-position of the particle
					position[i][1] = position[i-1][1]-1;			//Storing the temporal y-position of the particle
				}
				else								//If the nearby cell is occupied
				{
					position[i][0] = position[i-1][0];			//Storing the current temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Storing the current temporal y-position of the particle
				}
			}
			else									//For the case that the particle is at the boundary
			{
				if (board[x_pos][size-1] == 0)					//Check if the nearby cell at the other side of the board is not occupied
				{
					y_pos = size-1;						//Update the temporal y-position of the particle
					position[i][0] = position[i-1][0];			//Storing the temporal x-position of the particle
					position[i][1] = position[i-1][1]-1;			//Storing the temporal y-position of the particle
				}
				else								//If the nearby cell at the other side of the board is occupied
				{
					position[i][0] = position[i-1][0];			//Storing the current temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Storing the current temporal y-position of the particle
				}
			}
		}
		if (ran_num >= 0.5 && ran_num < 0.75)						//Rightward movement
		{
			if (x_pos != size-1)							//For the case that the particle is not at the boundary
			{
				if (board[x_pos+1][y_pos] == 0)					//Check if the nearby cell is not occupied
				{
					x_pos = x_pos+1;					//Update the temporal x-position of the particle
					position[i][0] = position[i-1][0]+1;			//Storing the temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Storing the temporal y-position of the particle
				}
				else								//If the nearby cell is occupied
				{
					position[i][0] = position[i-1][0];			//Storing the current temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Storing the current temporal y-position of the particle
				}
			}
			else									//For the case that the particle is at the boundary
			{
				if (board[0][y_pos] == 0)					//Check if the nearby cell at the other side of the board is not occupied
				{
					x_pos = 0;						//Update the temporal x-position of the particle
					position[i][0] = position[i-1][0]+1;			//Storing the temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Storing the temporal y-position of the particle
				}
				else								//If the nearby cell at the other side of the board is occupied
				{
					position[i][0] = position[i-1][0];			//Storing the current temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Storing the current temporal y-position of the particle
				}
			}
		}
		if (ran_num >= 0.75)								//Leftward movement
		{
			if (x_pos != 0)								//For the case that the particle is not at the boundary
			{
				if (board[x_pos-1][y_pos] == 0)					//Check if the nearby cell is not occupied
				{
					x_pos = x_pos-1;					//Update the temporal x-position of the particle
					position[i][0] = position[i-1][0]-1;			//Storing the temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Storing the temporal y-position of the particle
				}
				else												//If the nearby cell is not occupied
				{
					position[i][0] = position[i-1][0];			//Storing the current temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Storing the current temporal y-position of the particle
				}
			}
			else									//If the particle is at the boundary
			{
				if (board[size-1][y_pos] == 0)					//Check if the nearby cell at the other side of the board is not occupied
				{
					x_pos = size-1;						//Update the temporal x-position of the particle
					position[i][0] = position[i-1][0]-1;			//Storing the temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Storing the temporal y-position of the particle
				}
				else								//If the nearby cell at the other side of the board is occupied
				{
					position[i][0] = position[i-1][0];			//Storing the current temporal x-position of the particle
					position[i][1] = position[i-1][1];			//Stocing the current temporal y-position of the particle
				}
			}
		}
		//if (n<3)									//Only for the 4-first runs
		//{
		//	position_file << position[i][0] << "\t" << position[i][1] << endl;
		//}										//Streaming the position of the particle on par_pos.txt
	}
	//if(n<3) {position_file.close(); /*debug_file.close();*/}				//Since for only the 4-first runs the stream file is opened

	return position;
}
//-----------------------End of diffusion function--------------------//
